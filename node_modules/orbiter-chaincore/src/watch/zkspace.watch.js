"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZKSpaceWatch = void 0;
const dayjs_1 = __importDefault(require("dayjs"));
const lodash_1 = require("lodash");
const core_1 = require("../utils/core");
const base_watch_1 = __importDefault(require("./base.watch"));
/**
# ZKSpace

* type
 * zkRollup
 
* Tokens are supported (service charges can also be set)
 * ETH、ZKS、WBTC 和 USDT
 * **Gas fee:**Each Swap transaction needs to pay $1 equivalent Gas fee, which is used to amortize the cost of aggregating and packaging the results of multiple transactions on the platform and putting data on ETH blockchain.

* Official website
 *  [zks.org](https://zks.org/)

* Wallet (officially and test a domain name according to the link network)
 * [ZKSpace - Layer-2 for All](https://zks.app/wallet/token)

* github
 * [L2Labs · GitHub](https://github.com/l2labs)

* docs
 * [RESTful API - ZKSpace Wiki (English)](https://en.wiki.zks.org/interact-with-zkswap/restful-api)

* Block browser
 * mainnet [zkswap.info](https://zkswap.info/)
 * rinkeby： [ZKSpace Explorer](https://v3-rinkeby.zkswap.info/)
 */
class ZKSpaceWatch extends base_watch_1.default {
    constructor() {
        super(...arguments);
        this.minConfirmations = 0;
    }
    getApiFilter(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                types: "Transfer",
                limit: 100,
                start: 0,
            };
            yield this.apiScanCursor(address);
            return params;
        });
    }
    apiScanBetween(address, startTime, endTime) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let start = 0;
            const list = [];
            while (true) {
                try {
                    const response = yield this.chain.getTransactions(address, {
                        types: "Transfer",
                        limit: 100,
                        start,
                    });
                    if (response.txlist.length <= 0) {
                        break;
                    }
                    // const txs = orderBy(response.txlist, ["timestamp"], ["asc"]);
                    const matchTx = response.txlist.filter(tx => tx.timestamp >= startTime && tx.timestamp <= endTime);
                    list.push(...matchTx);
                    const maxTime = ((_a = (0, lodash_1.maxBy)(response.txlist, "timestamp")) === null || _a === void 0 ? void 0 : _a.timestamp) || 0;
                    const minTime = ((_b = (0, lodash_1.minBy)(response.txlist, "timestamp")) === null || _b === void 0 ? void 0 : _b.timestamp) || 0;
                    if (maxTime > endTime) {
                        break;
                    }
                    if (minTime < startTime) {
                        break;
                    }
                    yield (0, core_1.sleep)(500);
                    start++;
                }
                catch (error) {
                    this.logger.error(`zkSpace apiScanBetween Error:`, error);
                }
            }
            return (0, lodash_1.orderBy)(list, ["timestamp"], ["asc"]);
        });
    }
    apiWatchNewTransaction(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const filter = yield this.getApiFilter(address);
            const cursor = yield this.apiScanCursor(address);
            // const res = await this.apiScanBetween(address, 1657008749, dayjs().unix());
            const response = yield this.chain.getTransactions(address, filter);
            const prevTxTime = (cursor === null || cursor === void 0 ? void 0 : cursor.timestamp) || (0, dayjs_1.default)().unix();
            return response.txlist.filter(tx => tx.timestamp > prevTxTime);
        });
    }
    replayBlock(_start, _end, _changeBlock) {
        throw new Error("Method not implemented.");
    }
}
exports.ZKSpaceWatch = ZKSpaceWatch;
