"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("./core");
const AllChains_json_1 = __importDefault(require("../../AllChains.json"));
class Chain {
    static fill(configList) {
        const chains = configList.map((chain) => {
            var _a;
            if (!chain.workingStatus) {
                chain.workingStatus = "stop";
            }
            chain.tokens =
                ((_a = chain.tokens) === null || _a === void 0 ? void 0 : _a.map((row) => {
                    row.mainCoin = (0, core_1.equals)(row.address, chain.nativeCurrency.address);
                    return row;
                })) || [];
            if (chain.tokens.findIndex(token => (0, core_1.equals)(token.address, chain.nativeCurrency.address)) == -1) {
                chain.tokens.unshift({
                    id: chain.nativeCurrency.id,
                    name: chain.nativeCurrency.name,
                    symbol: chain.nativeCurrency.symbol,
                    decimals: chain.nativeCurrency.decimals,
                    address: chain.nativeCurrency.address,
                    mainCoin: true,
                });
            }
            return chain;
        });
        Chain.configs = chains;
        return chains;
    }
    static getAllChains() {
        return Chain.configs || [];
    }
    /**
     * @deprecated
     * @param chainId chainId
     * @param tokenAddress  token Address
     * @returns Chain Config
     */
    static getTokenByAddress(chainId, tokenAddress) {
        const chain = Chain.getInjectChain(chainId);
        return chain.tokens.find(row => (0, core_1.equals)(row.address, tokenAddress));
    }
    // private static getChain(chainId: string): IChainConfig {
    //   // Get injected chain
    //   const chain: IChainConfig | undefined = Chain.configs.find(
    //     x => x.chainId === chainId,
    //   );
    //   if (!chain || typeof chain === "undefined") {
    //     throw new Error(`No chain found matching chainId: ${chainId}`);
    //   }
    //   // Get the chain configuration in the template
    //   return chain;
    // }
    static getInjectChain(chainId) {
        const chain = Chain.configs.find(x => x.chainId === chainId);
        if (!chain || typeof chain === "undefined") {
            throw new Error(`No chain found matching chainId: ${chainId}`);
        }
        return chain;
    }
    /**
     * [Network Chain] Get Network All Chain Config
     * @returns ALL Chain Config
     */
    static getPubChains() {
        return AllChains_json_1.default;
    }
    /**
     * [Network Chain] Get Network All Chain Config
     * @param chainId  chainId
     * @returns Chain Config
     */
    static getPubChainInfo(chainId) {
        return AllChains_json_1.default.find((row) => (0, core_1.equals)(row.chainId, chainId));
    }
    /**
     * [Network Chain] Get Network All Chain Config
     * @param name  chain name
     * @returns Chain Config
     */
    static getPubChainInfoByName(name) {
        return AllChains_json_1.default.find((row) => (0, core_1.equals)(row.name, name));
    }
    /**
     * Get the injected public chain configuration according to the platform internal ID
     * @param internalId ID
     * @returns IChainConfig
     */
    static getChainByInternalId(internalId) {
        const chain = Chain.getChainByKeyValue("internalId", internalId);
        return chain;
    }
    /**
     * Get By Chain Main Token
     * @param chainId chainId
     * @returns Main Token Address
     */
    static getChainMainToken(chainId) {
        const chain = Chain.getInjectChain(chainId);
        return chain.nativeCurrency.address;
    }
    /**
     * Valid is MainToken
     * @param chainId chainId
     * @param tokenAddress tokenAddress
     * @returns is MainToken true | false
     */
    static inValidMainToken(chainId, tokenAddress) {
        const mainToken = Chain.getChainMainToken(chainId);
        return (0, core_1.equals)(mainToken, tokenAddress);
    }
    static inValidInternalId(internalId) {
        const index = Chain.configs.findIndex(row => (0, core_1.equals)(row.internalId, internalId));
        return index >= 0;
    }
    /**
     * Get the injected public chain configuration according to the platform Chain ID
     * @param internalId ID
     * @returns IChainConfig
     */
    static getChainByChainId(chainId) {
        const chain = Chain.getInjectChain(chainId);
        return chain;
    }
    static getChainByKeyValue(key, value) {
        const allChains = Chain.getAllChains();
        const chain = allChains.find(chain => (0, core_1.equals)(chain[key], value));
        if (typeof chain === "undefined") {
            throw new Error(`No chain found matching key: ${key}, value: ${value}`);
        }
        return Chain.getInjectChain(chain.chainId);
    }
    /**
     * @deprecated
     */
    static getChainByNetworkId(networkId) {
        const chain = Chain.getChainByKeyValue("networkId", networkId);
        return chain;
    }
}
exports.default = Chain;
Chain.configs = [];
