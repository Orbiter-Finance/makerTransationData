"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const imx_sdk_1 = require("@imtbl/imx-sdk");
const lodash_1 = require("lodash");
const utils_1 = require("../utils");
const base_watch_1 = __importDefault(require("./base.watch"));
const alchemy_sdk_1 = require("alchemy-sdk");
class EVMWatchAlchemyBase extends base_watch_1.default {
    constructor(chain, network) {
        super(chain);
        this.chain = chain;
        this.minConfirmations = 1;
        const rpcSplit = this.chain.chainConfig.rpc[0].split("/");
        const config = {
            apiKey: rpcSplit[rpcSplit.length - 1],
            network: network,
        };
        this.alchemy = new alchemy_sdk_1.Alchemy(config);
    }
    getApiFilter(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                address,
                sort: "asc",
                page: 1,
                offset: 100,
            };
            const cursor = yield this.apiScanCursor(address);
            if (cursor) {
                params.startblock = Number(cursor.blockNumber);
            }
            return params;
        });
    }
    apiWatchNewTransaction(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const trxList = [];
            const filter = yield this.getApiFilter(address);
            const chainConfig = this.chain.chainConfig;
            let hashList = [];
            try {
                const response = yield this.chain.apiClient.call(utils_1.EtherscanApiAction.AccountTxlist, filter);
                const { status, result } = response;
                if (status !== "1") {
                    this.logger.error(`AccountTxlist Fail:${JSON.stringify(response)} , Params:${JSON.stringify(filter)}`);
                }
                if (result && Array.isArray(result)) {
                    hashList.push(...result);
                }
            }
            catch (error) {
                this.logger.error(`AccountTxlist error, Params:${JSON.stringify(filter)}`, error);
            }
            if (chainConfig.tokens.length > 0) {
                try {
                    const response = yield this.chain.apiClient.call(utils_1.EtherscanApiAction.AccountTokentx, filter);
                    const { status, result } = response;
                    if (status !== "1") {
                        this.logger.error(`AccountTokentx Fail:${JSON.stringify(response)} , Params:${JSON.stringify(filter)}`);
                    }
                    if (result && Array.isArray(result)) {
                        hashList.push(...result);
                    }
                }
                catch (error) {
                    this.logger.error(`AccountTokentx error, Params:${JSON.stringify(filter)}`, error);
                }
            }
            try {
                const response = yield this.chain.apiClient.call(utils_1.EtherscanApiAction.AccountTxlistinternal, filter);
                const { status, result } = response;
                if (status !== "1") {
                    this.logger.error(`AccountTxlistinternal Fail:${JSON.stringify(response)} , Params:${JSON.stringify(filter)}`);
                }
                if (result && Array.isArray(result)) {
                    hashList.push(...result);
                }
            }
            catch (error) {
                this.logger.error(`AccountTxlistinternal error, Params:${JSON.stringify(filter)}`, error);
            }
            hashList = hashList
                .filter((row) => Number(row.blockNumber) >= filter.startblock)
                .map((row) => row.hash);
            for (const hash of (0, lodash_1.uniq)(hashList)) {
                const newTx = yield this.chain.convertTxToEntity(hash);
                newTx && trxList.push(newTx);
            }
            return trxList;
        });
    }
    replayBlockTransaction(hashOrTx) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const txmap = new Map();
            const originTx = typeof hashOrTx === "string"
                ? yield this.chain.getWeb3().eth.getTransaction(hashOrTx)
                : hashOrTx;
            if (!originTx || !originTx.to) {
                return txmap;
            }
            try {
                let isMatchTx = yield this.isWatchWalletAddress(originTx.from);
                if (!isMatchTx && (yield this.isWatchWalletAddress(originTx.to))) {
                    isMatchTx = true;
                }
                if (yield this.isWatchContractAddress(originTx.to)) {
                    isMatchTx = true;
                }
                if (yield this.isWatchXVMContractAddress(originTx.to)) {
                    isMatchTx = true;
                }
                if (!isMatchTx && originTx.input.length >= 138) {
                    // match2
                    for (const address of Array.from(this.watchAddress.keys())) {
                        if (originTx.input.includes(address.substring(2))) {
                            if (yield this.isWatchTokenAddress(originTx.to)) {
                                isMatchTx = true;
                                break;
                            }
                        }
                    }
                }
                if (!isMatchTx) {
                    return txmap;
                }
                const trx = yield this.chain.convertTxToEntity(originTx);
                if (!trx) {
                    return txmap;
                }
                let matchAddress = "";
                if (yield this.isWatchWalletAddress(trx.from)) {
                    matchAddress = trx.from;
                }
                else if (yield this.isWatchWalletAddress(trx.to)) {
                    matchAddress = trx.to;
                }
                else if (yield this.isWatchXVMContractAddress((_a = trx.extra) === null || _a === void 0 ? void 0 : _a.to)) {
                    matchAddress = trx.to;
                }
                if (!matchAddress) {
                    this.logger.info(`Matched but the resolved transaction failed to match: Address=${matchAddress}`, trx);
                    return txmap;
                }
                matchAddress = matchAddress.toLowerCase();
                this.logger.info(`[${this.chain.chainConfig.name}] replayBlock Match Transaction:Address=${matchAddress},matchAddress Hash=${String(originTx.hash)}`);
                if (!txmap.has(matchAddress))
                    txmap.set(matchAddress, []);
                (_b = txmap.get(matchAddress)) === null || _b === void 0 ? void 0 : _b.push(trx);
                return txmap;
            }
            catch (error) {
                this.logger.error(`${this.chain.chainConfig.name} replayBlockTransaction error:`, error);
                throw error;
            }
        });
    }
    replayBlock(start, end, changeBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const web3 = this.chain.getWeb3();
                const config = this.chain.chainConfig;
                config.debug &&
                    this.logger.info(`[${config.name}] Start replayBlock ${start}/${end - this.minConfirmations}/${end}`);
                while (start <= end - this.minConfirmations) {
                    try {
                        const timestamp = Date.now();
                        config.debug &&
                            this.logger.debug(`[${config.name} - replayBlock - GgetBlockBefore] Block:${start}/${end - this.minConfirmations}/${end},, timestamp:${timestamp}`);
                        const block = yield web3.eth.getBlock(start, true);
                        if (!block) {
                            yield (0, imx_sdk_1.sleep)(1000 * 2);
                            continue;
                        }
                        config.debug &&
                            this.logger.debug(`[${config.name} - replayBlock - GetBlockAfter] Block:${start}/${end - this.minConfirmations}/${end}, timestamp:${timestamp},Spend time:${(Date.now() - timestamp) / 1000}/s`);
                        const { transactions } = block;
                        config.debug &&
                            this.logger.info(`[${config.name} - replayBlock (${start}/${end - this.minConfirmations}/${end}), Trxs Count : ${transactions.length}`);
                        const txmap = new Map();
                        for (const tx of transactions) {
                            // Filter non whitelist address transactions
                            const matchTxList = yield this.replayBlockTransaction(tx);
                            matchTxList.forEach((txlist, address) => {
                                var _a;
                                if (!txmap.has(address))
                                    txmap.set(address, []);
                                (_a = txmap.get(address)) === null || _a === void 0 ? void 0 : _a.push(...txlist);
                            });
                        }
                        changeBlock && changeBlock(start, txmap);
                        config.debug &&
                            this.logger.debug(`[${config.name} - replayBlock - complete] Block:${start}, Latest:${end}, Next Block:${start + 1}, timestamp:${timestamp},Spend time:${(Date.now() - timestamp) / 1000}/s`);
                        start++;
                    }
                    catch (error) {
                        this.logger.error(`[${config.name}] replayBlock -> ScanBlock Error:`, error);
                    }
                }
                return { start, end };
            }
            catch (error) {
                this.logger.error(`replayBlock Error:`, error);
                throw error;
            }
        });
    }
}
exports.default = EVMWatchAlchemyBase;
