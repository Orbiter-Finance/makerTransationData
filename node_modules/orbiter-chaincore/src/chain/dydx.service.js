"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dydx = void 0;
const types_1 = require("../types");
const web3_1 = __importDefault(require("web3"));
const core_1 = require("../utils/core");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const dayjs_1 = __importDefault(require("dayjs"));
const v3_client_1 = require("@dydxprotocol/v3-client");
class Dydx {
    constructor(chainConfig) {
        var _a;
        this.chainConfig = chainConfig;
        this.apiKeyCredentials = {
            key: "",
            secret: "",
            passphrase: "",
        };
        if (!(0, core_1.isEmpty)(this.chainConfig.api.key)) {
            const keys = ((_a = this.chainConfig.api.key) === null || _a === void 0 ? void 0 : _a.split(".")) || [];
            this.apiKeyCredentials.key = keys[0];
            this.apiKeyCredentials.secret = keys[1];
            this.apiKeyCredentials.passphrase = keys[2];
        }
    }
    getTokenInfo(idOrAddrsss) {
        return __awaiter(this, void 0, void 0, function* () {
            if (idOrAddrsss === 0 ||
                idOrAddrsss === "0" ||
                idOrAddrsss === "0x0000000000000000000000000000000000000000") {
                return this.chainConfig.nativeCurrency;
            }
            if (typeof idOrAddrsss === "string") {
                // check local config
                const localToken = this.chainConfig.tokens.find(t => (0, core_1.equals)(t.address, idOrAddrsss));
                if (localToken) {
                    return localToken;
                }
            }
            return null;
        });
    }
    getDydxClient() {
        const apiKeyCredentials = this.apiKeyCredentials;
        if (!apiKeyCredentials.key ||
            !apiKeyCredentials.secret ||
            !apiKeyCredentials.passphrase) {
            throw new Error("Wallet signature not configured key | secret | passphrase");
        }
        const web3 = new web3_1.default();
        return new v3_client_1.DydxClient(this.chainConfig.api.url, {
            web3: web3,
            apiKeyCredentials,
            apiTimeout: 2000,
            networkId: Number(this.chainConfig.networkId),
        });
    }
    getLatestHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            return 0;
        });
    }
    convertTxToEntity(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data)
                return data;
            const { id, fromAddress, toAddress, status, createdAt } = data, extra = __rest(data, ["id", "fromAddress", "toAddress", "status", "createdAt"]);
            const value = new bignumber_js_1.default((0, core_1.equals)(extra.type, "TRANSFER_IN") ? data.creditAmount : data.debitAmount);
            const symbol = (0, core_1.equals)(extra.type, "TRANSFER_IN")
                ? data.creditAsset
                : data.debitAsset;
            const nonce = Dydx.timestampToNonce(new Date(createdAt).getTime());
            const token = yield this.chainConfig.tokens.find(t => (0, core_1.equals)(String(symbol), t.symbol));
            const tx = new types_1.Transaction({
                chainId: this.chainConfig.chainId,
                hash: id,
                nonce: Number(nonce),
                from: fromAddress || "",
                to: toAddress || "",
                blockNumber: 0,
                value,
                status: types_1.TransactionStatus.Fail,
                timestamp: (0, dayjs_1.default)(createdAt).unix(),
                fee: "0",
                feeToken: String(token === null || token === void 0 ? void 0 : token.symbol),
                tokenAddress: token === null || token === void 0 ? void 0 : token.address,
                extra,
                symbol,
            });
            if ((0, core_1.equals)(status, "PENDING")) {
                tx.status = types_1.TransactionStatus.PENDING;
            }
            else if ((0, core_1.equals)(status, "CONFIRMED")) {
                tx.status = types_1.TransactionStatus.COMPLETE;
            }
            return tx;
        });
    }
    getConfirmations(_hashOrHeight) {
        throw new Error("Method not implemented.");
    }
    calcConfirmations(_targetHeight, _latestHeight) {
        throw new Error("Method not implemented.");
    }
    getTransactionByHash(_hash) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Method not implemented.");
        });
    }
    /**
     * The api does not return the nonce value, timestamp(ms) last three number is the nonce
     *  (warnning: there is a possibility of conflict)
     * @param  timestamp ms
     * @returns
     */
    static timestampToNonce(timestamp) {
        let nonce = 0;
        if (timestamp) {
            timestamp = String(timestamp);
            const match = timestamp.match(/(\d{3})$/i);
            if (match && match.length > 1) {
                nonce = Number(match[1]) || 0;
            }
            if (nonce > 900) {
                nonce = nonce - 100;
            }
        }
        return String(nonce);
    }
    getTransactions(_address, filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {
                txlist: [],
            };
            const dydxClient = this.getDydxClient();
            const transfers = yield dydxClient.private
                .getTransfers({
                limit: filter.limit || 100,
                createdBeforeOrAt: (0, dayjs_1.default)(filter.createdBeforeOrAt || new Date()).toISOString(),
            })
                .then((result) => result.transfers || []);
            for (const row of transfers) {
                const tx = yield this.convertTxToEntity(row);
                if (tx) {
                    response.txlist.push(tx);
                }
            }
            return response;
        });
    }
    getTokenTransactions(address, tokenAddress, filter) {
        throw new Error("Method not implemented.");
    }
    getBalance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const dydxClient = this.getDydxClient();
            const { account } = yield dydxClient.private.getAccount(address);
            return new bignumber_js_1.default(account.freeCollateral);
        });
    }
    getBalances(_address) {
        return [];
    }
    getDecimals() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainConfig.nativeCurrency.decimals;
        });
    }
    getTokenBalance(address, tokenAddress) {
        throw new Error("Method not implemented.");
    }
    getTokenDecimals(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getTokenInfo(tokenAddress);
            if (!token) {
                throw new Error(`${tokenAddress} Token Not Exists`);
            }
            if (token) {
                return Number(token.decimals);
            }
            return 0;
        });
    }
    getTokenSymbol(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getTokenInfo(tokenAddress);
            if (!token) {
                throw new Error(`${tokenAddress} Token Not Exists`);
            }
            return token && token.symbol;
        });
    }
}
exports.Dydx = Dydx;
