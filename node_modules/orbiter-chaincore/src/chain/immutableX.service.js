"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImmutableX = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const types_1 = require("../types");
const imx_sdk_1 = require("@imtbl/imx-sdk");
const dayjs_1 = __importDefault(require("dayjs"));
const core_1 = require("../utils/core");
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
/**
 * https://immutascan.io/
 * https://docs.x.immutable.com/docs/welcome
 */
class ImmutableX {
    constructor(chainConfig) {
        this.chainConfig = chainConfig;
        this.tokens = [];
    }
    getLatestHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            return 0;
        });
    }
    createClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.client) {
                return this.client;
            }
            this.client = yield imx_sdk_1.ImmutableXClient.build({
                publicApiUrl: this.chainConfig.api.url,
            });
            return this.client;
        });
    }
    getTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokens.length <= 0) {
                // get all token list
                const { result: tokenList } = yield this.client.listTokens({});
                if (tokenList) {
                    this.tokens = tokenList.map((row) => {
                        return {
                            name: String(row.name),
                            symbol: String(row.symbol),
                            decimals: Number(row.decimals),
                            address: row.token_address ||
                                "0x0000000000000000000000000000000000000000",
                        };
                    });
                    yield (0, fs_extra_1.outputJSONSync)(path_1.default.join(process.env.RUNTIME_DIR || "runtime", `token/${this.chainConfig.internalId}-tokens.json`), this.tokens);
                }
            }
            return this.tokens;
        });
    }
    getTokenInfo(idOrAddrsss) {
        return __awaiter(this, void 0, void 0, function* () {
            if (idOrAddrsss === 0 ||
                idOrAddrsss === "0" ||
                idOrAddrsss === "0x0000000000000000000000000000000000000000") {
                return this.chainConfig.nativeCurrency;
            }
            const tokens = yield this.getTokenList();
            if (typeof idOrAddrsss === "string") {
                // check local config
                const localToken = this.chainConfig.tokens.find(t => (0, core_1.equals)(t.address, idOrAddrsss));
                if (localToken) {
                    return localToken;
                }
                return tokens.find(token => (0, core_1.equals)(token.address, idOrAddrsss));
            }
            else {
                return tokens.find(token => (0, core_1.equals)(token.id, idOrAddrsss));
            }
        });
    }
    getConfirmations(_hashOrHeight) {
        throw new Error("Method not implemented.");
    }
    calcConfirmations(_targetHeight, _latestHeight) {
        throw new Error("Method not implemented.");
    }
    getTransactionByHash(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.createClient();
            const rawTx = yield client.getTransfer({
                id: Number(hash),
            });
            if (rawTx) {
                return yield this.convertTxToEntity(rawTx);
            }
            return null;
        });
    }
    static timestampToNonce(timestamp) {
        let nonce = 0;
        if (timestamp) {
            timestamp = String(timestamp);
            const match = timestamp.match(/(\d{3})$/i);
            if (match && match.length > 1) {
                nonce = Number(match[1]) || 0;
            }
            if (nonce > 900) {
                nonce = nonce - 100;
            }
        }
        return nonce;
    }
    convertTxToEntity(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data)
                return data;
            const { transaction_id, user, receiver, timestamp, token } = data, extra = __rest(data, ["transaction_id", "user", "receiver", "timestamp", "token"]);
            const nonce = ImmutableX.timestampToNonce(timestamp.getTime());
            let tokenAddress = String(token.data["token_address"]);
            if ((0, core_1.isEmpty)(tokenAddress)) {
                tokenAddress = this.chainConfig.nativeCurrency.address;
            }
            let status = types_1.TransactionStatus.Fail;
            if (["success", "confirmed", "accepted"].includes(data.status)) {
                status = types_1.TransactionStatus.COMPLETE;
            }
            return new types_1.Transaction({
                chainId: this.chainConfig.chainId,
                hash: String(transaction_id),
                from: user,
                to: receiver,
                nonce,
                blockNumber: transaction_id,
                value: new bignumber_js_1.default(token.data.quantity.toString()),
                symbol: token.type,
                status,
                timestamp: (0, dayjs_1.default)(timestamp).unix(),
                fee: "0",
                feeToken: this.chainConfig.nativeCurrency.symbol,
                tokenAddress,
                extra,
            });
        });
    }
    getTransactions(address, filter = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.createClient();
            const response = {
                txlist: [],
            };
            const requestTx = (filterParams) => __awaiter(this, void 0, void 0, function* () {
                const response = {
                    txlist: [],
                };
                const _a = yield client.getTransfers(filterParams), { result } = _a, resExtra = __rest(_a, ["result"]);
                Object.assign(response, resExtra);
                for (const txRaw of result) {
                    const tx = yield this.convertTxToEntity(txRaw);
                    if (tx) {
                        response.txlist.push(tx);
                    }
                }
                return response;
            });
            const sendRes = yield requestTx(Object.assign({
                user: address,
            }, filter));
            const receiveRes = yield requestTx(Object.assign({
                receiver: address,
            }, filter));
            response.txlist.push(...sendRes.txlist);
            response.txlist.push(...receiveRes.txlist);
            response.txlist = (0, core_1.orderBy)(response.txlist, ["timestamp", "blockNumber"], ["desc", "desc"]);
            return response;
        });
    }
    getTokenTransactions(_address, _tokenAddress, _filter) {
        throw new Error("Method not implemented.");
    }
    getBalance(address) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.createClient();
            const { result } = yield client.listBalances({
                user: address,
            });
            if (result) {
                const row = result.find((row) => row.symbol === this.chainConfig.nativeCurrency.symbol);
                if (row) {
                    return new bignumber_js_1.default(((_a = row.balance) === null || _a === void 0 ? void 0 : _a.toString()) || 0);
                }
            }
            return new bignumber_js_1.default(0);
        });
    }
    getBalances(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.createClient();
            const { result } = yield client.listBalances({
                user: address,
            });
            if (result) {
                return result.map((row) => {
                    return {
                        balance: row.balance.toString(),
                        symbol: row.symbol,
                        token: row.token_address,
                    };
                });
            }
            return [];
        });
    }
    getDecimals() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainConfig.nativeCurrency.decimals;
        });
    }
    getTokenBalance(address, tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getTokenInfo(tokenAddress);
            if (!token) {
                throw new Error(`${tokenAddress} Token Not Exists`);
            }
            const client = yield this.createClient();
            const { balance } = yield client.getBalance({
                user: address,
                tokenAddress: tokenAddress,
            });
            return new bignumber_js_1.default((balance === null || balance === void 0 ? void 0 : balance.toString()) || 0);
        });
    }
    getTokenDecimals(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getTokenInfo(tokenAddress);
            if (!token) {
                throw new Error(`${tokenAddress} Token Not Exists`);
            }
            return Number(token.decimals);
        });
    }
    getTokenSymbol(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getTokenInfo(tokenAddress);
            if (!token) {
                throw new Error(`${tokenAddress} Token Not Exists`);
            }
            return token && token.symbol;
        });
    }
}
exports.ImmutableX = ImmutableX;
