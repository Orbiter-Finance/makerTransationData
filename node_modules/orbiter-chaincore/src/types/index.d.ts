/// <reference types="node" />
import { BigNumber } from "bignumber.js";
import { IChain, IChainConfigWorkingStatus } from "./chain";
import { ITransaction } from "./transaction";
export * from "./chain";
export * from "./transaction";
export declare type HashOrBlockNumber = string | number;
export declare type Hash = string;
export declare type Address = string;
export declare type replayBlockCallback = any;
export interface IChainWatch {
    chain: IChain;
    init(): Promise<any>;
    apiScan(): Promise<any>;
    rpcScan(): Promise<any>;
    apiScanCursor(address: Address, tx?: Partial<ITransaction>): Promise<Partial<ITransaction> | null>;
    isWatchWalletAddress(address: string): Promise<boolean>;
    isWatchContractAddress(address: string): Promise<boolean>;
    isWatchTokenAddress(address: string): Promise<boolean>;
    addWatchAddress(address: Array<Address> | Address): this;
}
export interface IChainWatchAlchemyApi extends IChainWatch {
    alchemyApiScan: Promise<any>;
}
export interface QueryTxFilter {
}
export interface QueryTxFilterMetis extends QueryTxFilter {
    address: string;
    sort?: string;
    startblock?: number;
    endblock?: number;
    page?: number;
    offset?: number;
    filterby?: string;
    starttimestamp?: number;
    endtimestamp?: number;
}
export interface TaskInfo {
    status: IChainConfigWorkingStatus;
    lastTime: number;
    fun?: Function;
    timer?: NodeJS.Timer;
}
export declare type TransactionHashOrObject = string | Object;
export interface QueryTxFilterEther extends QueryTxFilter {
    address: string;
    sort?: string;
    startblock?: number;
    endblock?: number;
    page?: number;
    offset?: number;
}
export interface QueryTxFilterZKSync extends QueryTxFilter {
    from: string | "latest";
    limit: number;
    direction: "newer" | "older";
}
export interface QueryTxFilterZKSpace extends QueryTxFilter {
    types: string;
    limit: number;
    start: number;
    token?: string;
}
export interface QueryTxFilterDydx extends QueryTxFilter {
    limit: number;
    createdBeforeOrAt: string;
}
export interface QueryTxFilterLoopring extends QueryTxFilter {
    accountId: number;
    start?: number;
    end?: number;
    status?: string;
    limit?: number;
    offset?: number;
    tokenSymbol?: string;
    transferTypes?: string;
}
export declare type AddressMapTransactions = Map<string, Array<ITransaction>>;
export interface QueryTxFilterIMX extends QueryTxFilter {
    order_by: string | null;
    page_size: number | null;
    cursor: string | null;
    direction: string | null;
    user: string | null;
    receiver: string | null;
    status: string | null;
    rollup_status: string | null;
    min_timestamp: string | null;
    max_timestamp: string | null;
    token_type: string | null;
    token_id: string | null;
    token_address: string | null;
    min_quantity: string | null;
    max_quantity: string | null;
    metadata: string | null;
}
export interface decodeInputContractTransferResponse {
    name: string;
    transferData: {
        recipient: string;
        amount: BigNumber;
        tokenAddress: string;
        ext: string;
    };
    data: any;
}
export interface TokeBalanceResponse {
    token: string;
    balance: string;
    symbol?: string;
}
export interface BalanceTokenItem {
    id?: Number;
    address: string;
    symbol: string;
    balance: string;
    decimals: number;
}
export interface TokenBalanceChain {
    address: string;
    name: string;
    chainId: string;
    internalId: string;
    balance: string;
    tokenBalances: Array<BalanceTokenItem>;
}
export interface TokenBalanceClass {
    getBalance(address: string, tokenAddress?: string): Promise<BalanceTokenItem>;
    getTokenBalance(address: string, tokenAddress: Array<string>): Promise<Array<BalanceTokenItem>>;
    getHoldTokens(address: string): Promise<Array<BalanceTokenItem>>;
}
