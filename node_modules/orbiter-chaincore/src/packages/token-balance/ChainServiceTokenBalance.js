"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainServiceTokenBalance = void 0;
const core_1 = require("../../utils/core");
const chainFactory_1 = require("../../watch/chainFactory");
class ChainServiceTokenBalance {
    constructor(chainId) {
        this.chainId = chainId;
        // Initialize an alchemy-web3 instancex:
        const { chain } = chainFactory_1.ChainFactory.createWatchChainByIntranetId(this.chainId);
        this.chainService = chain;
    }
    getBalance(address, tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const tokenInfo = (0, core_1.isEmpty)(tokenAddress)
                ? this.chainService.chainConfig.nativeCurrency
                : this.chainService.chainConfig.tokens.find(row => (0, core_1.equals)(row.address, String(tokenAddress)));
            if (!tokenInfo) {
                throw new Error("Token not configured");
            }
            const balance = (tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.mainCoin)
                ? yield this.chainService.getBalance(address)
                : yield this.chainService.getTokenBalance(address, String(tokenAddress));
            const result = {
                id: tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.id,
                address: tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.address,
                symbol: tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.symbol,
                balance: balance.toFixed(),
                decimals: tokenInfo === null || tokenInfo === void 0 ? void 0 : tokenInfo.decimals,
            };
            return result;
        });
    }
    getHoldTokens(address) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Not implemented");
        });
    }
    getTokenBalance(address, tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Not implemented");
        });
    }
}
exports.ChainServiceTokenBalance = ChainServiceTokenBalance;
