"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Loopring = void 0;
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const types_1 = require("../types");
const loopring_sdk_1 = require("@loopring-web/loopring-sdk");
const utils_1 = require("../utils");
const logger_1 = __importDefault(require("../utils/logger"));
const fs_extra_1 = require("fs-extra");
const path_1 = __importDefault(require("path"));
/**
 * https://beta.loopring.io/#/
 * https://docs.loopring.io/en/dex_apis/
 * https://explorer.loopring.io/
 */
class Loopring {
    constructor(chainConfig) {
        this.chainConfig = chainConfig;
        this.tokens = [];
    }
    getLatestHeight() {
        return __awaiter(this, void 0, void 0, function* () {
            return 0;
        });
    }
    getTokenList() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.tokens.length <= 0) {
                const { success, data } = yield utils_1.request.HttpGet(`${this.chainConfig.api.url}/exchange/tokens`);
                if (success && Array.isArray(data)) {
                    this.tokens = data.map(row => {
                        return {
                            id: row.tokenId,
                            name: row.name,
                            symbol: row.symbol,
                            decimals: row.decimals,
                            address: row.address,
                        };
                    });
                    yield (0, fs_extra_1.outputJSONSync)(path_1.default.join(process.env.RUNTIME_DIR || "runtime", `token/${this.chainConfig.internalId}-tokens.json`), this.tokens);
                }
                return this.tokens;
            }
            return this.tokens;
        });
    }
    getTokenInfo(idOrAddrsss) {
        return __awaiter(this, void 0, void 0, function* () {
            if (idOrAddrsss === 0 ||
                idOrAddrsss === "0" ||
                idOrAddrsss === "0x0000000000000000000000000000000000000000") {
                return this.chainConfig.nativeCurrency;
            }
            const tokens = yield this.getTokenList();
            if (typeof idOrAddrsss === "string") {
                // check local config
                const localToken = this.chainConfig.tokens.find(t => utils_1.core.equals(t.address, idOrAddrsss));
                if (localToken) {
                    return localToken;
                }
                return tokens.find(token => utils_1.core.equals(token.address, idOrAddrsss));
            }
            else {
                return tokens.find(token => utils_1.core.equals(token.id, idOrAddrsss));
            }
        });
    }
    getConfirmations(hashOrHeight) {
        throw new Error("Method not implemented.");
    }
    calcConfirmations(targetHeight, latestHeight) {
        throw new Error("Method not implemented.");
    }
    convertTxToEntity(data) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!data)
                return data;
            const { id, hash, amount, blockId, indexInBlock, senderAddress, receiverAddress, feeAmount, feeTokenSymbol, timestamp, status } = data, extra = __rest(data, ["id", "hash", "amount", "blockId", "indexInBlock", "senderAddress", "receiverAddress", "feeAmount", "feeTokenSymbol", "timestamp", "status"]);
            const storageInfo = data["storageInfo"];
            if (!storageInfo) {
                return null;
            }
            // nonce
            const nonce = (storageInfo.storageId - 1) / 2;
            const trxDTO = new types_1.Transaction({
                chainId: this.chainConfig.chainId,
                hash,
                from: senderAddress,
                to: receiverAddress,
                value: new bignumber_js_1.default(amount),
                nonce,
                blockHash: "",
                blockNumber: Number(blockId),
                transactionIndex: Number(indexInBlock),
                gas: 0,
                gasPrice: 0,
                fee: new bignumber_js_1.default(feeAmount).toString(),
                feeToken: feeTokenSymbol,
                input: "",
                symbol: "",
                tokenAddress: "",
                status: types_1.TransactionStatus.Fail,
                timestamp: parseInt(String(timestamp / 1000)),
                extra,
            });
            const token = yield this.getTokenInfo(storageInfo.tokenId);
            if (token) {
                trxDTO.symbol = token.symbol;
                trxDTO.tokenAddress = token.address;
            }
            if (status === "processed") {
                trxDTO.status = types_1.TransactionStatus.COMPLETE;
            }
            else if (status === "received") {
                trxDTO.status = types_1.TransactionStatus.PENDING;
            }
            return trxDTO;
        });
    }
    getTransactionByHash(hash) {
        return __awaiter(this, void 0, void 0, function* () {
            const networkId = Number(this.chainConfig.networkId);
            const userApi = new loopring_sdk_1.UserAPI({
                chainId: networkId,
            });
            const resData = yield userApi.getUserTransferList({
                hashes: hash,
            }, String(this.chainConfig.api.key));
            const userTransfers = resData.userTransfers;
            if (userTransfers &&
                Array.isArray(userTransfers) &&
                userTransfers.length > 0) {
                return yield this.convertTxToEntity(userTransfers[0]);
            }
            return null;
        });
    }
    getAccountInfo(address) {
        return __awaiter(this, void 0, void 0, function* () {
            const networkId = Number(this.chainConfig.networkId);
            const exchangeAPI = new loopring_sdk_1.ExchangeAPI({
                chainId: networkId,
            });
            const accountInfo = yield exchangeAPI.getAccount({
                owner: address,
            });
            return accountInfo;
        });
    }
    getTransactions(address, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {
                txlist: [],
            };
            try {
                const accountInfo = yield this.getAccountInfo(address);
                const networkId = Number(this.chainConfig.networkId);
                const userApi = new loopring_sdk_1.UserAPI({
                    chainId: networkId,
                });
                const params = Object.assign({
                    accountId: accountInfo.accInfo.accountId,
                }, filter);
                const resData = yield userApi.getUserTransferList(params, String(this.chainConfig.api.key));
                if (resData["code"]) {
                    logger_1.default.error("Loopring getUserTransferList Fail:", resData);
                    return response;
                }
                const userTransfers = resData.userTransfers;
                if (userTransfers &&
                    Array.isArray(userTransfers) &&
                    userTransfers.length > 0) {
                    for (const tx of userTransfers) {
                        const trx = yield this.convertTxToEntity(tx);
                        if (trx) {
                            response.txlist.push(trx);
                        }
                    }
                }
            }
            catch (error) {
                console.error("Get loopring txlist faild: ", error);
            }
            return response;
        });
    }
    getTokenTransactions(address, tokenAddress, filter) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = {
                txlist: [],
            };
            return response;
        });
    }
    getBalance(address) {
        throw new Error("Method not implemented.");
    }
    getBalances(address) {
        throw new Error("Method not implemented.");
    }
    getDecimals() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.chainConfig.nativeCurrency.decimals;
        });
    }
    getTokenBalance(address, tokenAddress) {
        throw new Error("Method not implemented.");
    }
    getTokenDecimals(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getTokenInfo(tokenAddress);
            if (!token) {
                throw new Error(`${tokenAddress} Token Not Exists`);
            }
            return token && token.decimals;
        });
    }
    getTokenSymbol(tokenAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            const token = yield this.getTokenInfo(tokenAddress);
            if (!token) {
                throw new Error(`${tokenAddress} Token Not Exists`);
            }
            return token && token.symbol;
        });
    }
}
exports.Loopring = Loopring;
