"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.decodeLogs = exports.decodeMethod = exports.ABIInputToString = exports.ABIToMapping = exports.XVM_ABI = exports.Forward_ABI = exports.ZKSYNC2_ABI_JSON = exports.IERC20_ABI_JSON = void 0;
const web3_utils_1 = require("web3-utils");
const web3_eth_abi_1 = __importDefault(require("web3-eth-abi"));
const bignumber_js_1 = __importDefault(require("bignumber.js"));
/* eslint-disable */
exports.IERC20_ABI_JSON = require("../abi/IERC20.json");
exports.ZKSYNC2_ABI_JSON = require("../abi/IERC20.json");
exports.Forward_ABI = require("../abi/Forward.json");
exports.XVM_ABI = require("../abi/XVM.json");
const ABIMap = new Map();
ABIMap.set("IERC20", {
    json: exports.IERC20_ABI_JSON,
    map: ABIToMapping(exports.IERC20_ABI_JSON),
});
ABIMap.set("Forward", {
    json: exports.Forward_ABI,
    map: ABIToMapping(exports.Forward_ABI),
});
ABIMap.set("XVM", {
    json: exports.XVM_ABI,
    map: ABIToMapping(exports.XVM_ABI),
});
function ABIToMapping(abi) {
    try {
        const abiMap = new Map();
        for (const abiItem of abi) {
            if (abiItem.name) {
                const signHex = (0, web3_utils_1.sha3)(`${abiItem.name}(${abiItem.inputs.map(ABIInputToString).join(",")})`);
                if (signHex) {
                    abiMap.set(abiItem.type === "event" ? signHex.slice(2) : signHex.slice(2, 10), abiItem);
                }
            }
        }
        return abiMap;
    }
    catch (error) {
        throw new Error(`Disassembly ABI failed ${error.message}`);
    }
}
exports.ABIToMapping = ABIToMapping;
function ABIInputToString(input) {
    if (input.type.includes("tuple")) {
        return `(${input.components.map(ABIInputToString).join(",")})`;
    }
    return input.type;
}
exports.ABIInputToString = ABIInputToString;
function decodeMethod(input, abiFile = "IERC20") {
    var _a;
    if (!ABIMap.has(abiFile)) {
        abiFile = "IERC20";
        // throw new Error(`${abiFile} Abi Name Not Exists`)
    }
    const abiItems = (_a = ABIMap.get(abiFile)) === null || _a === void 0 ? void 0 : _a.map;
    if (!abiItems) {
        throw new Error(`${abiFile} Abi Name items Not Exists`);
    }
    const signId = input.slice(2, 10);
    const abiItem = abiItems.get(signId);
    if (!abiItem) {
        return null;
    }
    const result = {
        name: abiItem.name,
        params: [],
    };
    const decodeResult = web3_eth_abi_1.default["decodeParameters"](abiItem.inputs, input.slice(10));
    for (let index = 0; index < decodeResult.__length__; index++) {
        const element = decodeResult[index];
        let values = element;
        const isUint = abiItem.inputs[index].type.includes("uint");
        const isInt = abiItem.inputs[index].type.includes("int");
        const isAddress = abiItem.inputs[index].type.includes("address");
        if (isUint || isInt) {
            if (Array.isArray(element)) {
                values = element.map(val => new bignumber_js_1.default(val).toString());
            }
            else {
                values = new bignumber_js_1.default(element).toString();
            }
        }
        // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all
        if (isAddress) {
            if (Array.isArray(element)) {
                values = element.map(el => el.toLowerCase());
            }
            else {
                values = element.toLowerCase();
            }
        }
        result.params.push({
            name: abiItem.inputs[index].name,
            value: values,
            type: abiItem.inputs[index].type,
        });
    }
    return result;
}
exports.decodeMethod = decodeMethod;
function decodeLogs(logs, abiFile = "IERC20") {
    var _a;
    if (!ABIMap.has(abiFile)) {
        abiFile = "IERC20";
        // throw new Error(`${abiFile} Abi Name Not Exists`)
    }
    const abiItems = (_a = ABIMap.get(abiFile)) === null || _a === void 0 ? void 0 : _a.map;
    if (!abiItems) {
        throw new Error(`${abiFile} Abi Name items Not Exists`);
    }
    return logs
        .filter((log) => log.topics.length > 0)
        .map((logItem) => {
        const method = abiItems.get(logItem.topics[0].slice(2));
        if (!method) {
            return null;
        }
        const logData = logItem.data;
        const decodedParams = [];
        let dataIndex = 0;
        let topicsIndex = 1;
        const dataTypes = [];
        method.inputs.map((input) => {
            if (!input.indexed) {
                dataTypes.push(input.type);
            }
        });
        const decodedData = web3_eth_abi_1.default["decodeParameters"](dataTypes, logData.slice(2));
        // Loop topic and data to get the params
        method.inputs.map(function (param) {
            const decodedP = {
                name: param.name,
                type: param.type,
            };
            if (param.indexed) {
                decodedP.value = logItem.topics[topicsIndex];
                topicsIndex++;
            }
            else {
                decodedP.value = decodedData[dataIndex];
                dataIndex++;
            }
            if (param.type === "address") {
                decodedP.value = decodedP.value.toLowerCase();
                // 42 because len(0x) + 40
                if (decodedP.value.length > 42) {
                    const toRemove = decodedP.value.length - 42;
                    const temp = decodedP.value.split("");
                    temp.splice(2, toRemove);
                    decodedP.value = temp.join("");
                }
            }
            // if (
            //   param.type === "uint256" ||
            //   param.type === "uint8" ||
            //   param.type === "int"
            // ) {
            //   // ensure to remove leading 0x for hex numbers
            //   if (typeof decodedP.value === "string" && decodedP.value.startsWith("0x")) {
            //     // decodedP.value = new BN(decodedP.value.slice(2), 16).toString(10);
            //   } else {
            //     // decodedP.value = new BN(decodedP.value).toString(10);
            //   }
            // }
            decodedParams.push(decodedP);
        });
        return {
            name: method.name,
            events: decodedParams,
            address: logItem.address,
        };
    });
}
exports.decodeLogs = decodeLogs;
