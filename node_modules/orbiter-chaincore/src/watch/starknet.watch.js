"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarknetWatch = void 0;
const lodash_1 = require("lodash");
const bignumber_js_1 = __importDefault(require("bignumber.js"));
const types_1 = require("../types");
const core_1 = require("../utils/core");
const base_watch_1 = __importDefault(require("./base.watch"));
const __1 = require("../..");
class StarknetWatch extends base_watch_1.default {
    constructor(chain) {
        super(chain);
        this.chain = chain;
        this.minConfirmations = 0;
    }
    getApiFilter(_address) {
        throw new Error("Method not implemented.");
    }
    replayBlockTransaction(hashOrTx) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const txmap = new Map();
            const originTx = typeof hashOrTx === "string"
                ? yield (yield this.chain.provider.getTransaction(hashOrTx)).transaction
                : hashOrTx;
            try {
                const from = (0, core_1.fix0xPadStartAddress)(originTx["contract_address"], 66);
                let isMatchTx = yield this.isWatchWalletAddress(from);
                const { transaction_hash } = originTx, extra = __rest(originTx, ["transaction_hash"]);
                const chainConfig = this.chain.chainConfig;
                const TxData = new types_1.Transaction({
                    chainId: chainConfig.chainId,
                    hash: transaction_hash,
                    from,
                    to: "",
                    value: new bignumber_js_1.default(0),
                    nonce: 0,
                    blockHash: "",
                    blockNumber: 0,
                    transactionIndex: 0,
                    gas: 0,
                    gasPrice: 0,
                    fee: "0",
                    feeToken: chainConfig.nativeCurrency.symbol,
                    input: "",
                    symbol: "",
                    tokenAddress: "",
                    status: types_1.TransactionStatus.Fail,
                    timestamp: 0,
                    extra,
                    source: "rpc",
                });
                if (!originTx.calldata) {
                    return txmap;
                }
                const transferSelector = "0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad";
                if (originTx.calldata.length === 12 &&
                    (0, core_1.equals)(originTx.entry_point_selector, transferSelector)) {
                    // user send
                    const recipientAddr = (0, core_1.fix0xPadStartAddress)(originTx.calldata[7], 66);
                    if (yield this.isWatchWalletAddress(recipientAddr)) {
                        const tokenAddr = (0, core_1.fix0xPadStartAddress)(originTx.calldata[6], 66);
                        const forwardContractAddr = (0, core_1.fix0xPadStartAddress)(originTx.calldata[1], 66);
                        if ((yield this.isWatchTokenAddress(tokenAddr)) &&
                            (yield this.isWatchContractAddress(forwardContractAddr))) {
                            TxData.symbol = yield this.chain.getTokenSymbol(tokenAddr);
                            TxData.tokenAddress = tokenAddr;
                            TxData.to = recipientAddr;
                            const nonce = originTx.calldata[11];
                            TxData.nonce = Number(nonce);
                            // fix Starknet will delete the 0 in front of the wallet address
                            TxData.extra["ext"] = (0, core_1.fix0xPadStartAddress)(originTx.calldata[10], 42);
                            TxData.value = new bignumber_js_1.default(originTx.calldata[8]);
                            isMatchTx = true;
                        }
                    }
                }
                // maker send
                // transfer 0x15d40a3d6ca2ac30f4031e42be28da9b056fef9bb7357ac5e85627ee876e5ad
                if (originTx.calldata.length === 10 &&
                    (0, core_1.equals)(originTx.entry_point_selector, transferSelector)) {
                    // maker send
                    const tokenAddr = (0, core_1.fix0xPadStartAddress)(originTx.calldata[1], 66);
                    if (yield this.isWatchTokenAddress(tokenAddr)) {
                        TxData.symbol = yield this.chain.getTokenSymbol(tokenAddr);
                        TxData.tokenAddress = tokenAddr;
                        TxData.to = (0, core_1.fix0xPadStartAddress)(originTx.calldata[6], 66);
                        const nonce = originTx.calldata[9];
                        TxData.nonce = Number(nonce);
                        TxData.value = new bignumber_js_1.default(originTx.calldata[7]);
                        isMatchTx = true;
                    }
                }
                if ((0, lodash_1.isEmpty)(TxData.from) || (0, lodash_1.isEmpty)(TxData.to)) {
                    return txmap;
                }
                let matchAddress = "";
                if (yield this.isWatchWalletAddress(TxData.from)) {
                    matchAddress = TxData.from;
                }
                else if (yield this.isWatchWalletAddress(TxData.to)) {
                    matchAddress = TxData.to;
                }
                if (!matchAddress) {
                    return txmap;
                }
                matchAddress = matchAddress.toLowerCase();
                if (!txmap.has(matchAddress))
                    txmap.set(matchAddress, []);
                (_a = txmap.get(matchAddress)) === null || _a === void 0 ? void 0 : _a.push(TxData);
                if (!isMatchTx || !TxData.from || !TxData.to) {
                    return txmap;
                }
                return txmap;
            }
            catch (error) {
                throw error;
            }
        });
    }
    replayByBlock(start) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.chain.provider;
            const config = this.chain.chainConfig;
            const timestamp = Date.now();
            const end = "latest";
            const block = yield provider.getBlock(start);
            const txmap = new Map();
            config.debug &&
                this.logger.debug(`[${config.name} - replayBlock - GetBlockAfter] Block:${start}/${end}, timestamp:${timestamp},Spend time:${(Date.now() - timestamp) / 1000}/s`);
            if (block) {
                const transactions = block.transactions;
                config.debug &&
                    this.logger.info(`[${config.name}] replayBlock (${start}//${end}), Trxs Count : ${transactions.length}`);
                for (const tx of transactions.filter(tx => tx.type === "INVOKE_FUNCTION")) {
                    // Filter non whitelist address transactions
                    const matchTxList = yield this.replayBlockTransaction(tx);
                    matchTxList.forEach((txlist, address) => {
                        var _a;
                        if (!txmap.has(address))
                            txmap.set(address, []);
                        for (const tx of txlist) {
                            if (tx.extra) {
                                tx.extra["blockStatus"] = block.status;
                            }
                            tx.blockHash = block.block_hash;
                            tx.blockNumber = block.block_number;
                            tx.timestamp = Number(block.timestamp);
                            tx.status = [
                                "ACCEPTED_ON_L1",
                                "ACCEPTED_ON_L2",
                                "PENDING",
                            ].includes(block.status)
                                ? types_1.TransactionStatus.COMPLETE
                                : types_1.TransactionStatus.Fail;
                            if (start === "pending") {
                                // update source
                                tx.source = `${tx.source}-pending`;
                            }
                            if (block.status === "ACCEPTED_ON_L2" &&
                                !this.pushHistory.has(`${tx.hash.toLowerCase()}:L2`)) {
                                __1.pubSub.publish(`ACCEPTED_ON_L2:${this.chain.chainConfig.internalId}`, tx);
                                this.pushHistory.set(`${tx.hash.toLowerCase()}:L2`, true);
                            }
                            const transactionReceipts = block.transaction_receipts;
                            const transactionReceipt = transactionReceipts.find(row => (0, core_1.equals)(row.transaction_hash, tx.hash));
                            if (transactionReceipt) {
                                tx.fee = String(Number(transactionReceipt["actual_fee"]));
                            }
                        }
                        (_a = txmap.get(address)) === null || _a === void 0 ? void 0 : _a.push(...txlist);
                    });
                }
                return txmap;
            }
            return txmap;
        });
    }
    replayBlock(start, end, changeBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // const pendingBlockTxs = await this.replayByBlock("pending");
                // if (pendingBlockTxs && pendingBlockTxs.size > 0) {
                //   // TAG: Do not push if the amount is less than 0.1
                //   changeBlock && changeBlock(0, pendingBlockTxs);
                // }
                const config = this.chain.chainConfig;
                config.debug &&
                    this.logger.info(`[${config.name} - Start replayBlock ${start}/${end}`);
                while (start <= end) {
                    try {
                        const txmap = yield this.replayByBlock(String(start));
                        changeBlock && changeBlock(start, txmap);
                        start++;
                    }
                    catch (error) {
                        this.logger.error(`[${config.name}] replayBlock Error:`, error);
                    }
                }
                return { start, end };
            }
            catch (error) {
                throw error;
            }
        });
    }
}
exports.StarknetWatch = StarknetWatch;
