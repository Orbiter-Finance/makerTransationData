"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IntervalTimerDecorator = exports.tasks = void 0;
/* eslint-disable */
const dayjs_1 = __importDefault(require("dayjs"));
const __1 = require("../..");
const logger_1 = __importDefault(require("../utils/logger"));
exports.tasks = new Map();
const IntervalTimerDecorator = (_target, _propertyKey, descriptor) => {
    const methods = descriptor.value;
    const methodsName = methods.name;
    try {
        descriptor.value = function () {
            // eslint-disable-next-line
            const that = this;
            const taskInfo = {
                status: "pause",
                lastTime: Date.now(),
                fun: methods,
                timer: undefined,
            };
            const config = that.chain.chainConfig;
            const intervalSeconds = config.api.intervalTime || 1000 * 5;
            const taskKey = `${config.internalId}:${methodsName}`;
            if (exports.tasks.has(taskKey)) {
                const task = exports.tasks.get(taskKey);
                if (task && task.timer) {
                    clearInterval(task.timer);
                }
            }
            const taskProcess = () => __awaiter(this, arguments, void 0, function* () {
                if (Date.now() % (60 * 2) === 0) {
                    logger_1.default.info(`[${config.name}-${methodsName}]- heartbeat  Last scan：${(0, dayjs_1.default)(taskInfo.lastTime).format("YYYY-MM-DD HH:mm:ss")} Every interval:${(Date.now() - taskInfo.lastTime) / 1000}s/${intervalSeconds / 1000}s, workingStatus:${taskInfo.status}`);
                }
                if (Date.now() - taskInfo.lastTime > 1000 * 60 * 5 &&
                    taskInfo.status === "running") {
                    clearInterval(taskInfo.timer);
                    exports.tasks.delete(taskKey);
                    logger_1.default.error(`[${config.name}-${methodsName}]- There are some problems. The chain scan may not be in progress. Now the scan will be restarted, status:${taskInfo.status}`);
                    return __1.ScanChainMain.reStartTask(config.internalId);
                }
                if (Date.now() - taskInfo.lastTime > intervalSeconds &&
                    taskInfo.status === "pause") {
                    try {
                        taskInfo.status = "running";
                        // eslint-disable-next-line
                        const result = yield methods.call(this, ...arguments);
                        taskInfo.lastTime = Date.now();
                        taskInfo.status = "pause";
                    }
                    catch (error) {
                        logger_1.default.error(`[${that.chain.chainConfig.name} - ${methodsName}] Scan Chain API Timer execution exception：`, error);
                        taskInfo.lastTime = Date.now();
                        taskInfo.status = "pause";
                    }
                }
            });
            taskInfo.timer = setInterval(taskProcess, 1000);
            exports.tasks.set(taskKey, taskInfo);
            return taskInfo;
        };
    }
    catch (error) {
        logger_1.default.error(`[${methodsName}] Scan Block IntervalTimerDecorator Error:`, error);
    }
};
exports.IntervalTimerDecorator = IntervalTimerDecorator;
